---
layout: page
title: About
---

For whatever reason, I've become increasingly more interested in software quality over the past few years. Maybe it's the perfectionist element- bugs bother me to the core, and the holy grail of "perfectly functioning software" is very enticing. Or it's the challenge of it- it's a puzzle of infamous difficulty, and I love the endorphin rush that comes at the end of solving a good puzzle. There's the human element too- a huge part of quality is determining whether or not the software is pleasing to its customers, and there's no greater joy than building something that people enjoy.

While these may explain my initial interest, there's a third element that keeps me hooked on the topic: its practical necessity. Today, teams of programmers are tasked with building and modifying applications of intimidating complexity week after week. Requirements change every day. Bugs are fixed as they arise. We've created innumerable tools focused on enabling software construction, but are we ending up with better products that provide their advertised value to customers?

Both the scale and pace of today's software makes it a very difficult craft to master, and I find the conventional wisdom of the industry to be lacking here. I've heard various reports that claim companies spend between 30-50% of their time and money on testing software, and testing is seen as the primary way for us to enable constant change in a software project. Yet, our test suites, which are computing an unfathomable number of decisions every day, often let subtle bugs through. To mitigate this, companies hire more and more programmers every year just to stay afloat. The economics of this are currently favorable (though that's arguable), but how long will that last? 

I think this puts us in the middle of a [second software crisis](https://en.wikipedia.org/wiki/Software_crisis). We're simply flying by the seat of our pants, shipping code and fixing bugs as they arise. While I'm skeptical about us being able to prove every line of software correct before shipping, there has to be a happy medium.

I'm hoping to collect posts here that circle around this one central notion, to be able to consider different aspects of the problem in an exploratory environment. If nothing else, it may be a useful resource for considering the many dimensions of software quality in one place.
